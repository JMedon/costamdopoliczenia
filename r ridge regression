## R function to fit the linear ridge regression model 2  3 linearRidge <- function(formula, data, lambda = "automatic", 4                         nPCs = NULL, scaling = c("corrForm", "scale", "none"), ...) 5   { 6     ## Check arguments 7     if(lambda != "automatic" && !is.null(nPCs)) 8       { 9         stop(gettextf("you cannot specify both lambda and nPCs\n")) 10       } else if(lambda == "automatic" && !is.null(nPCs)) { 11         lambda <- NULL 12       } 13     automatic <- FALSE 14     cl <- match.call() 15     m <- match.call(expand.dots = FALSE) 16     scaling <- match.arg(scaling) 17     if((lambda == "automatic" && !is.null(lambda)) && scaling != "corrForm") 18       { 19         warning("lambda is chosen automatically so scaling is set to \"corrForm\" ") 20         scaling <- "corrForm" 21         cl$scaling <- scaling 22       } 23     if(is.null(lambda) && scaling != "corrForm") 24       { 25         warning("lambda is chosen based on number of components so scaling is set to \"corrForm\"") 26         scaling <- "corrForm" 27         cl$scaling <- scaling 28       } 29     if(scaling == "none") 30       { 31         isScaled <- FALSE 32         corrForm <- FALSE 33         standardize <- FALSE 34       } else if (scaling == "corrForm") { 35         isScaled <- TRUE 36         corrForm <- TRUE 37         standardize <- FALSE 38       } else if (scaling == "scale") { 39         isScaled <- TRUE 40         corrForm <- FALSE 41         standardize <- TRUE 42       } 43     m$model <- m$allLambdas <- m$nPCs <- m$... <- m$lambda <- m$scaling <- NULL 44     m[[1L]] <- as.name("model.frame") 45     m <- eval.parent(m) 46     Terms <- attr(m, "terms") 47     ## Extract the response 48     Y <- model.response(m) 49     ## Construct the design matrix 50     X <- model.matrix(Terms, m) 51     ## get the dimensions of X in terms of n and p 52     n <- nrow(X) 53     p <- ncol(X) 54     if(!is.null(nPCs) && nPCs > min(n, p)) 55       stop(gettextf("You specified %d PCs which is greater than the maximum number of PCs in the data\n", nPCs)) 56     ## Handle the intercept 57     if (Inter <- attr(Terms, "intercept")) 58       { 59         Xm <- colMeans(X[, -Inter]) 60         Ym <- mean(Y) 61         p <- p - 1 62         ## Subtract the means from X 63         X <- X[, -Inter] - rep(Xm, rep(n, p)) 64         ## Subtract the mean from Y 65         Y <- Y - Ym 66       } else { 67         Xm <- colMeans(X) 68         Ym <- mean(Y) 69         ## Subtract the means from X 70         X <- X - rep(Xm, rep(n, p)) 71         ## Subtract the mean from y 72         Y <- Y - Ym 73       } 74  ## Calculate the scales 75      if(corrForm) 76        { 77          Xscale <- drop(rep(1/(n - 1), n) %*% apply(X, 2, function(x){x - mean(x)})^2)^0.5 * sqrt(nrow(X) - 1) 78        } else if (standardize) { 79          Xscale <- drop(rep(1/(n - 1), n) %*% apply(X, 2, function(x){x - mean(x)})^2)^0.5 80        } else { 81          Xscale <- drop(rep(1, p)) 82          names(Xscale) <- colnames(X) 83        } 84      X <- X/rep(Xscale, rep(n, p)) 85      Xs <- svd(X) 86      Q <- Xs$v 87      ## Make the principal components 88      Z <- X %*% Q 89      Lambda <- Xs$d^2 90      if(!is.null(lambda) && lambda == "automatic") 91        { 92          automatic <- TRUE 93          if(is.null(nPCs)) 94            { 95              propVar <- cumsum(Lambda) / sum(Lambda) * 100 96              nPCs <- which.max(propVar[propVar < 90]) + 1 97            } 98        } 99     ## Compute ahat 100     ahat <- diag(1 / Lambda) %*% t(Z) %*% Y 101     if(!is.null(lambda) && lambda == "automatic" && !is.null(nPCs)) 102       { 103         ks.vector <- sig2hat.vector <- vec.df <- numeric(nPCs) 104         flag <- TRUE 105         P <- 0 106         while((P < nPCs) && flag) 107           { 108             P <- P + 1 109             ## compute sig2hatP 110             sig2hat <- ifelse(P == 1, 111                               as.numeric(crossprod(Y - (Z[,1]) * ahat[1]) / (n - 1)), 112                               as.numeric(crossprod(Y - (Z[,1:P]) %*% ahat[1:P]) / (n - P)) 113                               ) 114             ## compute ahatsum 115             ahatsum <- ifelse(P == 1, 116                               ahat[1]^2, 117                               sum(ahat[1:P]^2) 118                               ) 119             ## compute kHKB 120             ks.vector[P] <- P * sig2hat / ahatsum 121             if(is.finite(ks.vector[P])) 122               { 123                 vec.df[ P ] <- sum(Lambda^2 / (Lambda + ks.vector[P])^2) 124               } 125             if(!is.finite(ks.vector[P])) 126               { 127                 flag <- FALSE 128                 ## make everything the correct dimensions 129                 ks.vector <- ks.vector[1:(P - 1)] 130               } 131           } ## Ends while loop 132         ## Choose best lambda 133         nPCs.dof <- which.min(abs(vec.df - seq(nPCs))) 134         ## Vector of lambdas 135         lambda <- ks.vector 136         ## The number of components 137         chosen.nPCs <- nPCs.dof 138         max.nPCs <- nPCs 139       } else if (!is.null(nPCs)) 140         { 141           P <- nPCs 142           sig2hat <- ifelse(P == 1, 143                             as.numeric(crossprod(Y - (Z[,1]) * ahat[1]) / (n - 1)), 144                             as.numeric(crossprod(Y - (Z[,1:P]) %*% ahat[1:P]) / (n - P)) 145                             ) 146           ahatsum <- ifelse(P == 1, 147                             ahat[1]^2, 148                             sum(ahat[1:P]^2) 149                             ) 150           ## compute lambda 151           lambda <- P * sig2hat / ahatsum 152           chosen.nPCs <- nPCs 153         } 154     ## compute coef as a matrix 155     aridge <- lapply(lambda, function(x) {ahat * Lambda / (Lambda + x)}) 156     coef <- lapply(aridge, function(x) {Q %*% x}) 157     ## compute df as a matrix 158     df <- lapply(lambda, function(x) {c(sum(Lambda / (Lambda + x)), sum(Lambda^2 / (Lambda + x)^2), sum(Lambda * (Lambda + 2* x) / (Lambda + x)^2))}) 159     coef <- do.call(cbind, coef) 160     rownames(coef) <- colnames(X) 161     ## 162     if(!is.null(nPCs)) 163       { 164         if(length(lambda) == 1) 165           { 166             colnames(coef) <- paste("nPCs", chosen.nPCs, sep = "") 167           } else { 168             colnames(coef) <- paste("nPCs", seq(max.nPCs), sep = "") 169           } 170       } else { 171         colnames(coef) <- paste("lambda=", lambda, sep = "") 172       } 173     ## 174     df <- do.call(rbind, df) 175     ## This line needs fixing 176     if(!is.null(nPCs)) 177       { 178         if(length(lambda) == 1) 179           { 180             rownames(df) <- paste("nPCs", chosen.nPCs, sep = "") 181           } else { 182             rownames(df) <- paste("nPCs", seq(max.nPCs), sep = "") 183           } 184       } else { 185         rownames(df) <- paste("lambda=", lambda, sep = "") 186       } 187     ## 188     colnames(df) <- c("model", "variance", "residual") 189     res <- list(automatic = automatic, call = cl, coef = cbind(drop(coef)), df = df, Inter = Inter, isScaled = isScaled, lambda = lambda, scales = Xscale, terms = Terms, x = X, xm = Xm, y = Y, ym = Ym) 190     ## This line needs fixing 191     if(!is.null(nPCs)) 192       { 193         if(automatic) 194           { 195             res$max.nPCs <- max.nPCs 196           } 197         res$chosen.nPCs <- chosen.nPCs 198       } 199     class(res) <- "ridgeLinear" 200     res 201   } 
